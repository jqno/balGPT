# Initialize database

> Awesome, thank you! Next, I'd like to populate the database with some tables. Can we run migrations from Go, just like in Ruby on Rails?
>
> We need 3 tables, each with a numeric autogenerated id field as primary key. The first table is called stats and has only one field for now, apart from the id: a timestamp named last_scrape.
>
> The second table is called teams and also has only one field: a varchar called name. Add an index to booth the id and name fields.
>
> The last table is called matches. Its fields are the id, a foreign key to teams called home_team, another foreign key to teams called away_team, numeric fields home_goals and away_goals, and a date. Let's have indices on the id, the foreign key fields, and the date.
>
> We also need to fill in that connection string based on environment variables.

Sure! To manage database migrations in Go, you can use a library like go-migrate/migrate. First, you'll need to install the CLI tool and the required database drivers:

```sh
$ go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest
```

Now, create a folder to store the migration files:

```sh
$ mkdir -p db/migrations
```

Next, create the migration files for creating the tables:

```sh
$ touch db/migrations/01_create_stats_table.up.sql
$ touch db/migrations/01_create_stats_table.down.sql
$ touch db/migrations/02_create_teams_table.up.sql
$ touch db/migrations/02_create_teams_table.down.sql
$ touch db/migrations/03_create_matches_table.up.sql
$ touch db/migrations/03_create_matches_table.down.sql
```

Fill in the migration files with the necessary SQL statements:

db/migrations/01_create_stats_table.up.sql:

```sql
CREATE TABLE stats (
    id SERIAL PRIMARY KEY,
    last_scrape TIMESTAMP NOT NULL
);
```

db/migrations/01_create_stats_table.down.sql:

```sql
DROP TABLE stats;
```

db/migrations/02_create_teams_table.up.sql:

```sql
CREATE TABLE teams (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE INDEX idx_teams_id ON teams(id);
CREATE INDEX idx_teams_name ON teams(name);
```

db/migrations/02_create_teams_table.down.sql:

```sql
DROP INDEX idx_teams_name;
DROP INDEX idx_teams_id;
DROP TABLE teams;
```

db/migrations/03_create_matches_table.up.sql:

```sql
CREATE TABLE matches (
    id SERIAL PRIMARY KEY,
    home_team INTEGER REFERENCES teams(id),
    away_team INTEGER REFERENCES teams(id),
    home_goals INTEGER,
    away_goals INTEGER,
    date DATE NOT NULL
);

CREATE INDEX idx_matches_id ON matches(id);
CREATE INDEX idx_matches_home_team ON matches(home_team);
CREATE INDEX idx_matches_away_team ON matches(away_team);
CREATE INDEX idx_matches_date ON matches(date);
```

db/migrations/03_create_matches_table.down.sql:

```sql
DROP INDEX idx_matches_date;
DROP INDEX idx_matches_away_team;
DROP INDEX idx_matches_home_team;
DROP INDEX idx_matches_id;
DROP TABLE matches;
```

To fill in the connection string based on environment variables, you can update the LoadConfig function in internal/config/config.go. Make sure to use os.Getenv for each of the required variables:

```go
package config

import (
	"fmt"
	"os"
)

type Config struct {
	DBConnectionString string
}

func LoadConfig() *Config {
	dbHost := os.Getenv("DB_HOST")
	dbPort := os.Getenv("DB_PORT")
	dbUser := os.Getenv("DB_USER")
	dbPass := os.Getenv("DB_PASS")
	dbName := os.Getenv("DB_NAME")

	connectionString := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", dbHost, dbPort, dbUser, dbPass, dbName)

	return &Config{
		DBConnectionString: connectionString,
	}
}
```

Now you can use the migrate CLI tool to apply the migrations:

```sh
$ migrate -path db/migrations -database "postgres://$DB_USER:$DB_PASS@$DB_HOST:$DB_PORT/$DB_NAME?sslmode=disable" up
```

And to rollback the migrations:

```sh
$ migrate -path db/migrations -database "postgres://$DB_USER:$DB_PASS@$DB_HOST
```

## Note

Later, I manually added some shell scripts to help me manage the database.
